import type { ContentTypeProps } from 'contentful-management'
import type { ContentTypeId, EnvironmentOrigin, FieldIdGroup, FieldIdMapForAll, IdMap, InternalFieldId } from './types'

/*
/* Util functions used in the below getFieldIdMapping function
*/

export const getAllFieldIdsFromContentType = (internalContentType: ContentTypeProps): FieldIdGroup[] =>
  internalContentType.fields.map((field) => ({
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    externalId: field.apiName!,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    internalId: field.id!,
  }))

export const getAllFieldIdsByContentType = (
  internalContentTypes: ContentTypeProps[]
): Record<ContentTypeId, FieldIdGroup[]> => {
  return internalContentTypes.reduce((acc, contentType) => {
    return {
      ...acc,
      [contentType.sys.id]: getAllFieldIdsFromContentType(contentType),
    }
  }, {})
}

export const getInternalIds = (fields: FieldIdGroup[]): InternalFieldId[] => fields.map((field) => field.internalId)

export const getFieldIdsToMatchBy = (fieldIds: FieldIdGroup[], internalIdsToMatch: InternalFieldId[]): IdMap => {
  return fieldIds.reduce((idMap, field) => {
    const { externalId, internalId } = field
    if (internalIdsToMatch.includes(internalId)) {
      idMap.set(externalId, internalId)
    } else {
      idMap.set(externalId, externalId)
    }
    return idMap
  }, new Map())
}

/**
 * @description
 * Function to create a field id mapping between source and target field ids
 * for all content types, to be used during field hash creation.
 * Takes the source and target content models in their internal shape as parameters.
 */
export const getFieldIdMapping = (
  sourceInternal: ContentTypeProps[],
  targetInternal: ContentTypeProps[]
): FieldIdMapForAll => {
  // for each content type, we group the internal and external id of each field
  const sourceFieldIdsByContentType = getAllFieldIdsByContentType(sourceInternal)
  const targetFieldIdsByContentType = getAllFieldIdsByContentType(targetInternal)

  // we collect the content types ids of the content types that exist in both environments
  const idsOfContentTypesInBothEnvironments = Object.keys(sourceFieldIdsByContentType).filter(
    (contentTypeId) => targetFieldIdsByContentType[contentTypeId] !== undefined
  )

  const fieldIdMapping = idsOfContentTypesInBothEnvironments
    // we group source and target per content type
    .map<[ContentTypeId, Record<EnvironmentOrigin, FieldIdGroup[]>]>((contentTypeId) => [
      contentTypeId,
      {
        source: sourceFieldIdsByContentType[contentTypeId],
        target: targetFieldIdsByContentType[contentTypeId],
      },
    ])
    // for each field of each content type, we get the best id to match by (internal or external)
    // and return a mapping in the form of
    // Map { externalId1 => id1ToMatchBy, externalId2 => id2ToMatchBy, ... }
    // per content type for both source and target
    .reduce<FieldIdMapForAll>((FieldIdMapForAll, [contentTypeId, fieldIds]) => {
      const internalIdsSource = getInternalIds(fieldIds.source)
      const internalIdsTarget = getInternalIds(fieldIds.target)

      const sourceFieldIds = getFieldIdsToMatchBy(fieldIds.source, internalIdsTarget)
      const targetFieldIds = getFieldIdsToMatchBy(fieldIds.target, internalIdsSource)

      FieldIdMapForAll.set(contentTypeId, { source: sourceFieldIds, target: targetFieldIds })

      return FieldIdMapForAll
    }, new Map())

  return fieldIdMapping
}
