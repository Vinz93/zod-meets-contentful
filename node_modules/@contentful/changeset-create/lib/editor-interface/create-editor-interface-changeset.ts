import { ContentTypeProps, EditorInterfaceProps } from 'contentful-management'
import { createChangesetForEntityCollection } from '../common'
import { editorInterfacePatch } from './editor-interface-patch'
import { createDefaultEditorInterface } from '@contentful/changeset-utils'

interface CreateEditorInterfaceChangesetParams {
  sourceModel: EditorInterfaceProps[]
  targetModel: EditorInterfaceProps[]
  sourceContentModel?: ContentTypeProps[]
}

/**
 * @param {EditorInterfaceProps} item
 * returns An editorInterface object with id set to it's content type id
 */
function transform(item: EditorInterfaceProps): EditorInterfaceProps {
  return {
    ...item,
    sys: {
      ...item.sys,
      id: item.sys.contentType.sys.id,
    },
  }
}

// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
export function createEditorInterfaceChangeset({
  sourceModel,
  targetModel,
  sourceContentModel,
}: CreateEditorInterfaceChangesetParams) {
  // We exclude the editor interface controls for content type fields that are not present in the source environment.
  // This is because otherwise we'd assume that those content type fields are being generated in the target which can lead to the
  // creation of patches that change field controls that don't exist.
  // This case can only happen when user manually deletes the field via API
  if (sourceContentModel) {
    // Create a lookup object for sourceContentModel
    const contentTypeLookup = sourceContentModel.reduce((acc: any, sourceContentType) => {
      acc[sourceContentType.sys.id] = sourceContentType.fields.map((field) => field.id)
      return acc
    }, {})

    sourceModel.forEach((item) => {
      const contentTypeId = item.sys.contentType.sys.id
      if (contentTypeLookup[contentTypeId]) {
        item.controls = item.controls?.filter((control) => contentTypeLookup[contentTypeId].includes(control.fieldId))
      }
    })
  }

  const transformedSource = sourceModel.map(transform)
  const transformedTarget = targetModel.map(transform)
  const targetIds = new Set(transformedTarget.map((item) => item.sys.id))
  const added = transformedSource.filter(({ sys: { id } }) => !targetIds.has(id))

  return createChangesetForEntityCollection({
    itemType: 'EditorInterface',
    sourceCollection: transformedSource,
    targetCollection: [
      ...transformedTarget,
      ...added.map((editorInterface) => createDefaultEditorInterface(editorInterface)),
    ],
    createEntityPatch: (sourceEntity, targetEntity) =>
      editorInterfacePatch({
        sourceItem: sourceEntity,
        targetItem: targetEntity,
      }),
  })
}
