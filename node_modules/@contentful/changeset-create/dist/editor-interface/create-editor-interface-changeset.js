"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEditorInterfaceChangeset = void 0;
const common_1 = require("../common");
const editor_interface_patch_1 = require("./editor-interface-patch");
const changeset_utils_1 = require("@contentful/changeset-utils");
/**
 * @param {EditorInterfaceProps} item
 * returns An editorInterface object with id set to it's content type id
 */
function transform(item) {
    return {
        ...item,
        sys: {
            ...item.sys,
            id: item.sys.contentType.sys.id,
        },
    };
}
// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
function createEditorInterfaceChangeset({ sourceModel, targetModel, sourceContentModel, }) {
    // We exclude the editor interface controls for content type fields that are not present in the source environment.
    // This is because otherwise we'd assume that those content type fields are being generated in the target which can lead to the
    // creation of patches that change field controls that don't exist.
    // This case can only happen when user manually deletes the field via API
    if (sourceContentModel) {
        // Create a lookup object for sourceContentModel
        const contentTypeLookup = sourceContentModel.reduce((acc, sourceContentType) => {
            acc[sourceContentType.sys.id] = sourceContentType.fields.map((field) => field.id);
            return acc;
        }, {});
        sourceModel.forEach((item) => {
            const contentTypeId = item.sys.contentType.sys.id;
            if (contentTypeLookup[contentTypeId]) {
                item.controls = item.controls?.filter((control) => contentTypeLookup[contentTypeId].includes(control.fieldId));
            }
        });
    }
    const transformedSource = sourceModel.map(transform);
    const transformedTarget = targetModel.map(transform);
    const targetIds = new Set(transformedTarget.map((item) => item.sys.id));
    const added = transformedSource.filter(({ sys: { id } }) => !targetIds.has(id));
    return (0, common_1.createChangesetForEntityCollection)({
        itemType: 'EditorInterface',
        sourceCollection: transformedSource,
        targetCollection: [
            ...transformedTarget,
            ...added.map((editorInterface) => (0, changeset_utils_1.createDefaultEditorInterface)(editorInterface)),
        ],
        createEntityPatch: (sourceEntity, targetEntity) => (0, editor_interface_patch_1.editorInterfacePatch)({
            sourceItem: sourceEntity,
            targetItem: targetEntity,
        }),
    });
}
exports.createEditorInterfaceChangeset = createEditorInterfaceChangeset;
