"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFieldIdMapping = exports.getFieldIdsToMatchBy = exports.getInternalIds = exports.getAllFieldIdsByContentType = exports.getAllFieldIdsFromContentType = void 0;
/*
/* Util functions used in the below getFieldIdMapping function
*/
const getAllFieldIdsFromContentType = (internalContentType) => internalContentType.fields.map((field) => ({
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    externalId: field.apiName,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    internalId: field.id,
}));
exports.getAllFieldIdsFromContentType = getAllFieldIdsFromContentType;
const getAllFieldIdsByContentType = (internalContentTypes) => {
    return internalContentTypes.reduce((acc, contentType) => {
        return {
            ...acc,
            [contentType.sys.id]: (0, exports.getAllFieldIdsFromContentType)(contentType),
        };
    }, {});
};
exports.getAllFieldIdsByContentType = getAllFieldIdsByContentType;
const getInternalIds = (fields) => fields.map((field) => field.internalId);
exports.getInternalIds = getInternalIds;
const getFieldIdsToMatchBy = (fieldIds, internalIdsToMatch) => {
    return fieldIds.reduce((idMap, field) => {
        const { externalId, internalId } = field;
        if (internalIdsToMatch.includes(internalId)) {
            idMap.set(externalId, internalId);
        }
        else {
            idMap.set(externalId, externalId);
        }
        return idMap;
    }, new Map());
};
exports.getFieldIdsToMatchBy = getFieldIdsToMatchBy;
/**
 * @description
 * Function to create a field id mapping between source and target field ids
 * for all content types, to be used during field hash creation.
 * Takes the source and target content models in their internal shape as parameters.
 */
const getFieldIdMapping = (sourceInternal, targetInternal) => {
    // for each content type, we group the internal and external id of each field
    const sourceFieldIdsByContentType = (0, exports.getAllFieldIdsByContentType)(sourceInternal);
    const targetFieldIdsByContentType = (0, exports.getAllFieldIdsByContentType)(targetInternal);
    // we collect the content types ids of the content types that exist in both environments
    const idsOfContentTypesInBothEnvironments = Object.keys(sourceFieldIdsByContentType).filter((contentTypeId) => targetFieldIdsByContentType[contentTypeId] !== undefined);
    const fieldIdMapping = idsOfContentTypesInBothEnvironments
        // we group source and target per content type
        .map((contentTypeId) => [
        contentTypeId,
        {
            source: sourceFieldIdsByContentType[contentTypeId],
            target: targetFieldIdsByContentType[contentTypeId],
        },
    ])
        // for each field of each content type, we get the best id to match by (internal or external)
        // and return a mapping in the form of
        // Map { externalId1 => id1ToMatchBy, externalId2 => id2ToMatchBy, ... }
        // per content type for both source and target
        .reduce((FieldIdMapForAll, [contentTypeId, fieldIds]) => {
        const internalIdsSource = (0, exports.getInternalIds)(fieldIds.source);
        const internalIdsTarget = (0, exports.getInternalIds)(fieldIds.target);
        const sourceFieldIds = (0, exports.getFieldIdsToMatchBy)(fieldIds.source, internalIdsTarget);
        const targetFieldIds = (0, exports.getFieldIdsToMatchBy)(fieldIds.target, internalIdsSource);
        FieldIdMapForAll.set(contentTypeId, { source: sourceFieldIds, target: targetFieldIds });
        return FieldIdMapForAll;
    }, new Map());
    return fieldIdMapping;
};
exports.getFieldIdMapping = getFieldIdMapping;
