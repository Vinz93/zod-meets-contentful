var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DiffPatcher: () => DiffPatcher,
  clone: () => clone2,
  console: () => console_exports,
  create: () => create,
  diff: () => diff,
  formatters: () => formatters_exports,
  patch: () => patch,
  reverse: () => reverse,
  unpatch: () => unpatch
});
module.exports = __toCommonJS(src_exports);

// src/processor.ts
var Processor = class {
  constructor(options) {
    this.selfOptions = options || {};
    this.pipes = {};
  }
  options(options) {
    if (options) {
      this.selfOptions = options;
    }
    return this.selfOptions;
  }
  pipe(name, pipeArg) {
    let pipe = pipeArg;
    if (typeof name === "string") {
      if (typeof pipe === "undefined") {
        return this.pipes[name];
      } else {
        this.pipes[name] = pipe;
      }
    }
    if (name && name.name) {
      pipe = name;
      if (pipe.processor === this) {
        return pipe;
      }
      this.pipes[pipe.name] = pipe;
    }
    pipe.processor = this;
    return pipe;
  }
  process(input, pipe) {
    let context = input;
    context.options = this.options();
    let nextPipe = pipe || input.pipe || "default";
    let lastPipe;
    let lastContext;
    while (nextPipe) {
      if (typeof context.nextAfterChildren !== "undefined") {
        context.next = context.nextAfterChildren;
        context.nextAfterChildren = null;
      }
      if (typeof nextPipe === "string") {
        nextPipe = this.pipe(nextPipe);
      }
      nextPipe.process(context);
      lastContext = context;
      lastPipe = nextPipe;
      nextPipe = null;
      if (context) {
        if (context.next) {
          context = context.next;
          nextPipe = lastContext.nextPipe || context.pipe || lastPipe;
        }
      }
    }
    return context.hasResult ? context.result : void 0;
  }
};
var processor_default = Processor;

// src/pipe.ts
var Pipe = class {
  constructor(name) {
    this.name = name;
    this.filters = [];
  }
  process(input) {
    if (!this.processor) {
      throw new Error("add this pipe to a processor before using it");
    }
    let debug = this.debug;
    let length = this.filters.length;
    let context = input;
    for (let index = 0; index < length; index++) {
      let filter = this.filters[index];
      if (debug) {
        this.log(`filter: ${filter.filterName}`);
      }
      filter(context);
      if (typeof context === "object" && context.exiting) {
        context.exiting = false;
        break;
      }
    }
    if (!context.next && this.resultCheck) {
      this.resultCheck(context);
    }
  }
  log(msg) {
    console.log(`[jsondiffpatch] ${this.name} pipe, ${msg}`);
  }
  append(...args) {
    this.filters.push(...args);
    return this;
  }
  prepend(...args) {
    this.filters.unshift(...args);
    return this;
  }
  indexOf(filterName) {
    if (!filterName) {
      throw new Error("a filter name is required");
    }
    for (let index = 0; index < this.filters.length; index++) {
      let filter = this.filters[index];
      if (filter.filterName === filterName) {
        return index;
      }
    }
    throw new Error(`filter not found: ${filterName}`);
  }
  list() {
    return this.filters.map((f) => f.filterName);
  }
  after(filterName) {
    let index = this.indexOf(filterName);
    let params = Array.prototype.slice.call(arguments, 1);
    if (!params.length) {
      throw new Error("a filter is required");
    }
    params.unshift(index + 1, 0);
    Array.prototype.splice.apply(this.filters, params);
    return this;
  }
  before(filterName) {
    let index = this.indexOf(filterName);
    let params = Array.prototype.slice.call(arguments, 1);
    if (!params.length) {
      throw new Error("a filter is required");
    }
    params.unshift(index, 0);
    Array.prototype.splice.apply(this.filters, params);
    return this;
  }
  replace(filterName) {
    let index = this.indexOf(filterName);
    let params = Array.prototype.slice.call(arguments, 1);
    if (!params.length) {
      throw new Error("a filter is required");
    }
    params.unshift(index, 1);
    Array.prototype.splice.apply(this.filters, params);
    return this;
  }
  remove(filterName) {
    let index = this.indexOf(filterName);
    this.filters.splice(index, 1);
    return this;
  }
  clear() {
    this.filters.length = 0;
    return this;
  }
  shouldHaveResult(should) {
    if (should === false) {
      this.resultCheck = null;
      return;
    }
    if (this.resultCheck) {
      return;
    }
    let pipe = this;
    this.resultCheck = (context) => {
      if (!context.hasResult) {
        console.log(context);
        let error = new Error(`${pipe.name} failed`);
        error.noResult = true;
        throw error;
      }
    };
    return this;
  }
};
var pipe_default = Pipe;

// src/contexts/context.ts
var Context = class {
  setResult(result) {
    this.result = result;
    this.hasResult = true;
    return this;
  }
  exit() {
    this.exiting = true;
    return this;
  }
  // Love it when it's not used :sad_face:
  switchTo(next, pipe) {
    if (typeof next === "string" || next instanceof pipe_default) {
      this.nextPipe = next;
    } else {
      this.next = next;
      if (pipe) {
        this.nextPipe = pipe;
      }
    }
    return this;
  }
  push(child, name) {
    child.parent = this;
    if (typeof name !== "undefined") {
      child.childName = name;
    }
    child.root = this.root || this;
    child.options = child.options || this.options;
    if (!this.children) {
      this.children = [child];
      this.nextAfterChildren = this.next || null;
      this.next = child;
    } else {
      this.children[this.children.length - 1].next = child;
      this.children.push(child);
    }
    child.next = this;
    return this;
  }
};

// src/clone.js
var isArray = typeof Array.isArray === "function" ? Array.isArray : (a) => a instanceof Array;
function cloneRegExp(re) {
  let regexMatch = /^\/(.*)\/([gimyu]*)$/.exec(re.toString());
  return new RegExp(regexMatch[1], regexMatch[2]);
}
function clone(arg) {
  if (typeof arg !== "object") {
    return arg;
  }
  if (arg === null) {
    return null;
  }
  if (isArray(arg)) {
    return arg.map(clone);
  }
  if (arg instanceof Date) {
    return new Date(arg.getTime());
  }
  if (arg instanceof RegExp) {
    return cloneRegExp(arg);
  }
  let cloned = {};
  for (let name in arg) {
    if (Object.prototype.hasOwnProperty.call(arg, name)) {
      cloned[name] = clone(arg[name]);
    }
  }
  return cloned;
}

// src/contexts/diff.ts
var DiffContext = class extends Context {
  constructor(left, right) {
    super();
    this.left = left;
    this.right = right;
    this.pipe = "diff";
  }
  setResult(result) {
    if (this.options.cloneDiffValues && typeof result === "object") {
      const clone3 = typeof this.options.cloneDiffValues === "function" ? this.options.cloneDiffValues : clone;
      if (typeof result[0] === "object") {
        result[0] = clone3(result[0]);
      }
      if (typeof result[1] === "object") {
        result[1] = clone3(result[1]);
      }
    }
    return Context.prototype.setResult.apply(this, arguments);
  }
};
var diff_default = DiffContext;

// src/contexts/patch.ts
var PatchContext = class extends Context {
  constructor(left, delta) {
    super();
    this.left = left;
    this.delta = delta;
    this.pipe = "patch";
  }
};
var patch_default = PatchContext;

// src/contexts/reverse.ts
var ReverseContext = class extends Context {
  constructor(delta) {
    super();
    this.delta = delta;
    this.pipe = "reverse";
  }
};
var reverse_default = ReverseContext;

// src/filters/trivial.js
var isArray2 = typeof Array.isArray === "function" ? Array.isArray : function(a) {
  return a instanceof Array;
};
var diffFilter = function trivialMatchesDiffFilter(context) {
  if (context.left === context.right) {
    context.setResult(void 0).exit();
    return;
  }
  if (typeof context.left === "undefined") {
    if (typeof context.right === "function") {
      throw new Error("functions are not supported");
    }
    context.setResult([context.right]).exit();
    return;
  }
  if (typeof context.right === "undefined") {
    context.setResult([context.left, 0, 0]).exit();
    return;
  }
  if (typeof context.left === "function" || typeof context.right === "function") {
    throw new Error("functions are not supported");
  }
  context.leftType = context.left === null ? "null" : typeof context.left;
  context.rightType = context.right === null ? "null" : typeof context.right;
  if (context.leftType !== context.rightType) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === "boolean" || context.leftType === "number") {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === "object") {
    context.leftIsArray = isArray2(context.left);
  }
  if (context.rightType === "object") {
    context.rightIsArray = isArray2(context.right);
  }
  if (context.leftIsArray !== context.rightIsArray) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.left instanceof RegExp) {
    if (context.right instanceof RegExp) {
      context.setResult([context.left.toString(), context.right.toString()]).exit();
    } else {
      context.setResult([context.left, context.right]).exit();
    }
  }
};
diffFilter.filterName = "trivial";
var patchFilter = function trivialMatchesPatchFilter(context) {
  if (typeof context.delta === "undefined") {
    context.setResult(context.left).exit();
    return;
  }
  context.nested = !isArray2(context.delta);
  if (context.nested) {
    return;
  }
  if (context.delta.length === 1) {
    context.setResult(context.delta[0]).exit();
    return;
  }
  if (context.delta.length === 2) {
    if (context.left instanceof RegExp) {
      const regexArgs = /^\/(.*)\/([gimyu]+)$/.exec(context.delta[1]);
      if (regexArgs) {
        context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();
        return;
      }
    }
    context.setResult(context.delta[1]).exit();
    return;
  }
  if (context.delta.length === 3 && context.delta[2] === 0) {
    context.setResult(void 0).exit();
  }
};
patchFilter.filterName = "trivial";
var reverseFilter = function trivialReferseFilter(context) {
  if (typeof context.delta === "undefined") {
    context.setResult(context.delta).exit();
    return;
  }
  context.nested = !isArray2(context.delta);
  if (context.nested) {
    return;
  }
  if (context.delta.length === 1) {
    context.setResult([context.delta[0], 0, 0]).exit();
    return;
  }
  if (context.delta.length === 2) {
    context.setResult([context.delta[1], context.delta[0]]).exit();
    return;
  }
  if (context.delta.length === 3 && context.delta[2] === 0) {
    context.setResult([context.delta[0]]).exit();
  }
};
reverseFilter.filterName = "trivial";

// src/filters/nested.js
function collectChildrenDiffFilter(context) {
  if (!context || !context.children) {
    return;
  }
  const length = context.children.length;
  let child;
  let result = context.result;
  for (let index = 0; index < length; index++) {
    child = context.children[index];
    if (typeof child.result === "undefined") {
      continue;
    }
    result = result || {};
    result[child.childName] = child.result;
  }
  if (result && context.leftIsArray) {
    result._t = "a";
  }
  context.setResult(result).exit();
}
collectChildrenDiffFilter.filterName = "collectChildren";
function objectsDiffFilter(context) {
  if (context.leftIsArray || context.leftType !== "object") {
    return;
  }
  let name;
  let child;
  const propertyFilter = context.options.propertyFilter;
  for (name in context.left) {
    if (!Object.prototype.hasOwnProperty.call(context.left, name)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name, context)) {
      continue;
    }
    child = new diff_default(context.left[name], context.right[name]);
    context.push(child, name);
  }
  for (name in context.right) {
    if (!Object.prototype.hasOwnProperty.call(context.right, name)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name, context)) {
      continue;
    }
    if (typeof context.left[name] === "undefined") {
      child = new diff_default(void 0, context.right[name]);
      context.push(child, name);
    }
  }
  if (!context.children || context.children.length === 0) {
    context.setResult(void 0).exit();
    return;
  }
  context.exit();
}
objectsDiffFilter.filterName = "objects";
var patchFilter2 = function nestedPatchFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  let name;
  let child;
  for (name in context.delta) {
    child = new patch_default(context.left[name], context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
patchFilter2.filterName = "objects";
var collectChildrenPatchFilter = function collectChildrenPatchFilter2(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  let length = context.children.length;
  let child;
  for (let index = 0; index < length; index++) {
    child = context.children[index];
    if (Object.prototype.hasOwnProperty.call(context.left, child.childName) && child.result === void 0) {
      delete context.left[child.childName];
    } else if (context.left[child.childName] !== child.result) {
      context.left[child.childName] = child.result;
    }
  }
  context.setResult(context.left).exit();
};
collectChildrenPatchFilter.filterName = "collectChildren";
var reverseFilter2 = function nestedReverseFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  let name;
  let child;
  for (name in context.delta) {
    child = new reverse_default(context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
reverseFilter2.filterName = "objects";
function collectChildrenReverseFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  let length = context.children.length;
  let child;
  let delta = {};
  for (let index = 0; index < length; index++) {
    child = context.children[index];
    if (delta[child.childName] !== child.result) {
      delta[child.childName] = child.result;
    }
  }
  context.setResult(delta).exit();
}
collectChildrenReverseFilter.filterName = "collectChildren";

// src/filters/lcs.js
var defaultMatch = function(array1, array2, index1, index2) {
  return array1[index1] === array2[index2];
};
var lengthMatrix = function(array1, array2, match, context) {
  const len1 = array1.length;
  const len2 = array2.length;
  let x, y;
  let matrix = [len1 + 1];
  for (x = 0; x < len1 + 1; x++) {
    matrix[x] = [len2 + 1];
    for (y = 0; y < len2 + 1; y++) {
      matrix[x][y] = 0;
    }
  }
  matrix.match = match;
  for (x = 1; x < len1 + 1; x++) {
    for (y = 1; y < len2 + 1; y++) {
      if (match(array1, array2, x - 1, y - 1, context)) {
        matrix[x][y] = matrix[x - 1][y - 1] + 1;
      } else {
        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);
      }
    }
  }
  return matrix;
};
var backtrack = function(matrix, array1, array2, context) {
  let index1 = array1.length;
  let index2 = array2.length;
  const subsequence = {
    sequence: [],
    indices1: [],
    indices2: []
  };
  while (index1 !== 0 && index2 !== 0) {
    const sameLetter = matrix.match(
      array1,
      array2,
      index1 - 1,
      index2 - 1,
      context
    );
    if (sameLetter) {
      subsequence.sequence.unshift(array1[index1 - 1]);
      subsequence.indices1.unshift(index1 - 1);
      subsequence.indices2.unshift(index2 - 1);
      --index1;
      --index2;
    } else {
      const valueAtMatrixAbove = matrix[index1][index2 - 1];
      const valueAtMatrixLeft = matrix[index1 - 1][index2];
      if (valueAtMatrixAbove > valueAtMatrixLeft) {
        --index2;
      } else {
        --index1;
      }
    }
  }
  return subsequence;
};
var get = function(array1, array2, match, context) {
  const innerContext = context || {};
  const matrix = lengthMatrix(
    array1,
    array2,
    match || defaultMatch,
    innerContext
  );
  const result = backtrack(matrix, array1, array2, innerContext);
  if (typeof array1 === "string" && typeof array2 === "string") {
    result.sequence = result.sequence.join("");
  }
  return result;
};
var lcs_default = {
  get
};

// src/filters/arrays.js
var ARRAY_MOVE = 3;
var isArray3 = typeof Array.isArray === "function" ? Array.isArray : (a) => a instanceof Array;
var arrayIndexOf = typeof Array.prototype.indexOf === "function" ? (array, item) => array.indexOf(item) : (array, item) => {
  let length = array.length;
  for (let i = 0; i < length; i++) {
    if (array[i] === item) {
      return i;
    }
  }
  return -1;
};
function arraysHaveMatchByRef(array1, array2, len1, len2) {
  for (let index1 = 0; index1 < len1; index1++) {
    let val1 = array1[index1];
    for (let index2 = 0; index2 < len2; index2++) {
      let val2 = array2[index2];
      if (index1 !== index2 && val1 === val2) {
        return true;
      }
    }
  }
}
function matchItems(array1, array2, index1, index2, context) {
  let value1 = array1[index1];
  let value2 = array2[index2];
  if (value1 === value2) {
    return true;
  }
  if (typeof value1 !== "object" || typeof value2 !== "object") {
    return false;
  }
  let objectHash = context.objectHash;
  if (!objectHash) {
    return context.matchByPosition && index1 === index2;
  }
  let hash1;
  let hash2;
  if (typeof index1 === "number") {
    context.hashCache1 = context.hashCache1 || [];
    hash1 = context.hashCache1[index1];
    if (typeof hash1 === "undefined") {
      context.hashCache1[index1] = hash1 = objectHash(value1, index1, "right");
    }
  } else {
    hash1 = objectHash(value1, index1, "right");
  }
  if (typeof hash1 === "undefined") {
    return false;
  }
  if (typeof index2 === "number") {
    context.hashCache2 = context.hashCache2 || [];
    hash2 = context.hashCache2[index2];
    if (typeof hash2 === "undefined") {
      context.hashCache2[index2] = hash2 = objectHash(value2, index2, "left");
    }
  } else {
    hash2 = objectHash(value2, index2, "left");
  }
  if (typeof hash2 === "undefined") {
    return false;
  }
  return hash1 === hash2;
}
var diffFilter2 = function arraysDiffFilter(context) {
  if (!context.leftIsArray) {
    return;
  }
  let matchContext = {
    objectHash: context.options && context.options.objectHash,
    matchByPosition: context.options && context.options.matchByPosition
  };
  let commonHead = 0;
  let commonTail = 0;
  let index;
  let index1;
  let index2;
  let array1 = context.left;
  let array2 = context.right;
  let len1 = array1.length;
  let len2 = array2.length;
  let child;
  if (len1 > 0 && len2 > 0 && !matchContext.objectHash && typeof matchContext.matchByPosition !== "boolean") {
    matchContext.matchByPosition = !arraysHaveMatchByRef(
      array1,
      array2,
      len1,
      len2
    );
  }
  while (commonHead < len1 && commonHead < len2 && matchItems(array1, array2, commonHead, commonHead, matchContext)) {
    index = commonHead;
    child = new diff_default(context.left[index], context.right[index]);
    context.push(child, index);
    commonHead++;
  }
  while (commonTail + commonHead < len1 && commonTail + commonHead < len2 && matchItems(
    array1,
    array2,
    len1 - 1 - commonTail,
    len2 - 1 - commonTail,
    matchContext
  )) {
    index1 = len1 - 1 - commonTail;
    index2 = len2 - 1 - commonTail;
    child = new diff_default(context.left[index1], context.right[index2]);
    context.push(child, index2);
    commonTail++;
  }
  let result;
  if (commonHead + commonTail === len1) {
    if (len1 === len2) {
      context.setResult(void 0).exit();
      return;
    }
    result = result || {
      _t: "a"
    };
    for (index = commonHead; index < len2 - commonTail; index++) {
      result[index] = [array2[index]];
    }
    context.setResult(result).exit();
    return;
  }
  if (commonHead + commonTail === len2) {
    result = result || {
      _t: "a"
    };
    for (index = commonHead; index < len1 - commonTail; index++) {
      result[`_${index}`] = [array1[index], 0, 0];
    }
    context.setResult(result).exit();
    return;
  }
  delete matchContext.hashCache1;
  delete matchContext.hashCache2;
  let trimmed1 = array1.slice(commonHead, len1 - commonTail);
  let trimmed2 = array2.slice(commonHead, len2 - commonTail);
  let seq = lcs_default.get(trimmed1, trimmed2, matchItems, matchContext);
  let removedItems = [];
  result = result || {
    _t: "a"
  };
  for (index = commonHead; index < len1 - commonTail; index++) {
    if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {
      result[`_${index}`] = [array1[index], 0, 0];
      removedItems.push(index);
    }
  }
  let detectMove = true;
  if (context.options && context.options.arrays && context.options.arrays.detectMove === false) {
    detectMove = false;
  }
  let includeValueOnMove = false;
  if (context.options && context.options.arrays && context.options.arrays.includeValueOnMove) {
    includeValueOnMove = true;
  }
  let removedItemsLength = removedItems.length;
  for (index = commonHead; index < len2 - commonTail; index++) {
    let indexOnArray2 = arrayIndexOf(seq.indices2, index - commonHead);
    if (indexOnArray2 < 0) {
      let isMove = false;
      if (detectMove && removedItemsLength > 0) {
        for (let removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {
          index1 = removedItems[removeItemIndex1];
          if (matchItems(
            trimmed1,
            trimmed2,
            index1 - commonHead,
            index - commonHead,
            matchContext
          )) {
            result[`_${index1}`].splice(1, 2, index, ARRAY_MOVE);
            if (!includeValueOnMove) {
              result[`_${index1}`][0] = "";
            }
            index2 = index;
            child = new diff_default(
              context.left[index1],
              context.right[index2]
            );
            context.push(child, index2);
            removedItems.splice(removeItemIndex1, 1);
            isMove = true;
            break;
          }
        }
      }
      if (!isMove) {
        result[index] = [array2[index]];
      }
    } else {
      index1 = seq.indices1[indexOnArray2] + commonHead;
      index2 = seq.indices2[indexOnArray2] + commonHead;
      child = new diff_default(context.left[index1], context.right[index2]);
      context.push(child, index2);
    }
  }
  context.setResult(result).exit();
};
diffFilter2.filterName = "arrays";
var compare = {
  numerically(a, b) {
    return a - b;
  },
  numericallyBy(name) {
    return (a, b) => a[name] - b[name];
  }
};
var patchFilter3 = function nestedPatchFilter2(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t !== "a") {
    return;
  }
  let index;
  let index1;
  let delta = context.delta;
  let array = context.left;
  let toRemove = [];
  let toInsert = [];
  let toModify = [];
  for (index in delta) {
    if (index !== "_t") {
      if (index[0] === "_") {
        if (delta[index][2] === 0 || delta[index][2] === ARRAY_MOVE) {
          toRemove.push(parseInt(index.slice(1), 10));
        } else {
          throw new Error(
            `only removal or move can be applied at original array indices, invalid diff type: ${delta[index][2]}`
          );
        }
      } else {
        if (delta[index].length === 1) {
          toInsert.push({
            index: parseInt(index, 10),
            value: delta[index][0]
          });
        } else {
          toModify.push({
            index: parseInt(index, 10),
            delta: delta[index]
          });
        }
      }
    }
  }
  toRemove = toRemove.sort(compare.numerically);
  for (index = toRemove.length - 1; index >= 0; index--) {
    index1 = toRemove[index];
    let indexDiff = delta[`_${index1}`];
    let removedValue = array.splice(index1, 1)[0];
    if (indexDiff[2] === ARRAY_MOVE) {
      toInsert.push({
        index: indexDiff[1],
        value: removedValue
      });
    }
  }
  toInsert = toInsert.sort(compare.numericallyBy("index"));
  let toInsertLength = toInsert.length;
  for (index = 0; index < toInsertLength; index++) {
    let insertion = toInsert[index];
    array.splice(insertion.index, 0, insertion.value);
  }
  let toModifyLength = toModify.length;
  let child;
  if (toModifyLength > 0) {
    for (index = 0; index < toModifyLength; index++) {
      let modification = toModify[index];
      child = new patch_default(
        context.left[modification.index],
        modification.delta
      );
      context.push(child, modification.index);
    }
  }
  if (!context.children) {
    context.setResult(context.left).exit();
    return;
  }
  context.exit();
};
patchFilter3.filterName = "arrays";
var collectChildrenPatchFilter3 = function collectChildrenPatchFilter4(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t !== "a") {
    return;
  }
  let length = context.children.length;
  let child;
  for (let index = 0; index < length; index++) {
    child = context.children[index];
    context.left[child.childName] = child.result;
  }
  context.setResult(context.left).exit();
};
collectChildrenPatchFilter3.filterName = "arraysCollectChildren";
var reverseFilter3 = function arraysReverseFilter(context) {
  if (!context.nested) {
    if (context.delta[2] === ARRAY_MOVE) {
      context.newName = `_${context.delta[1]}`;
      context.setResult([
        context.delta[0],
        parseInt(context.childName.substr(1), 10),
        ARRAY_MOVE
      ]).exit();
    }
    return;
  }
  if (context.delta._t !== "a") {
    return;
  }
  let name;
  let child;
  for (name in context.delta) {
    if (name === "_t") {
      continue;
    }
    child = new reverse_default(context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
reverseFilter3.filterName = "arrays";
var reverseArrayDeltaIndex = (delta, index, itemDelta) => {
  if (typeof index === "string" && index[0] === "_") {
    return parseInt(index.substr(1), 10);
  } else if (isArray3(itemDelta) && itemDelta[2] === 0) {
    return `_${index}`;
  }
  let reverseIndex = +index;
  for (let deltaIndex in delta) {
    let deltaItem = delta[deltaIndex];
    if (isArray3(deltaItem)) {
      if (deltaItem[2] === ARRAY_MOVE) {
        let moveFromIndex = parseInt(deltaIndex.substr(1), 10);
        let moveToIndex = deltaItem[1];
        if (moveToIndex === +index) {
          return moveFromIndex;
        }
        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {
          reverseIndex++;
        } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {
          reverseIndex--;
        }
      } else if (deltaItem[2] === 0) {
        let deleteIndex = parseInt(deltaIndex.substr(1), 10);
        if (deleteIndex <= reverseIndex) {
          reverseIndex++;
        }
      } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {
        reverseIndex--;
      }
    }
  }
  return reverseIndex;
};
function collectChildrenReverseFilter2(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t !== "a") {
    return;
  }
  let length = context.children.length;
  let child;
  let delta = {
    _t: "a"
  };
  for (let index = 0; index < length; index++) {
    child = context.children[index];
    let name = child.newName;
    if (typeof name === "undefined") {
      name = reverseArrayDeltaIndex(
        context.delta,
        child.childName,
        child.result
      );
    }
    if (delta[name] !== child.result) {
      delta[name] = child.result;
    }
  }
  context.setResult(delta).exit();
}
collectChildrenReverseFilter2.filterName = "arraysCollectChildren";

// src/filters/dates.js
var diffFilter3 = function datesDiffFilter(context) {
  if (context.left instanceof Date) {
    if (context.right instanceof Date) {
      if (context.left.getTime() !== context.right.getTime()) {
        context.setResult([context.left, context.right]);
      } else {
        context.setResult(void 0);
      }
    } else {
      context.setResult([context.left, context.right]);
    }
    context.exit();
  } else if (context.right instanceof Date) {
    context.setResult([context.left, context.right]).exit();
  }
};
diffFilter3.filterName = "dates";

// src/filters/texts.js
var import_diff_match_patch = __toESM(require("diff-match-patch"));
var TEXT_DIFF = 2;
var DEFAULT_MIN_LENGTH = 60;
var cachedDiffPatch = null;
var getDiffMatchPatch = function(required) {
  if (!cachedDiffPatch) {
    let instance;
    if (typeof diff_match_patch !== "undefined") {
      instance = typeof diff_match_patch === "function" ? new diff_match_patch() : new diff_match_patch.diff_match_patch();
    } else if (import_diff_match_patch.default) {
      try {
        instance = import_diff_match_patch.default && new import_diff_match_patch.default();
      } catch (err) {
        instance = null;
      }
    }
    if (!instance) {
      if (!required) {
        return null;
      }
      let error = new Error("text diff_match_patch library not found");
      error.diff_match_patch_not_found = true;
      throw error;
    }
    cachedDiffPatch = {
      diff: function(txt1, txt2) {
        return instance.patch_toText(instance.patch_make(txt1, txt2));
      },
      patch: function(txt1, patch2) {
        let results = instance.patch_apply(
          instance.patch_fromText(patch2),
          txt1
        );
        for (let i = 0; i < results[1].length; i++) {
          if (!results[1][i]) {
            let error = new Error("text patch failed");
            error.textPatchFailed = true;
          }
        }
        return results[0];
      }
    };
  }
  return cachedDiffPatch;
};
var diffFilter4 = function textsDiffFilter(context) {
  if (context.leftType !== "string") {
    return;
  }
  let minLength = context.options && context.options.textDiff && context.options.textDiff.minLength || DEFAULT_MIN_LENGTH;
  if (context.left.length < minLength || context.right.length < minLength) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  let diffMatchPatch = getDiffMatchPatch();
  if (!diffMatchPatch) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  let diff2 = diffMatchPatch.diff;
  context.setResult([diff2(context.left, context.right), 0, TEXT_DIFF]).exit();
};
diffFilter4.filterName = "texts";
var patchFilter4 = function textsPatchFilter(context) {
  if (context.nested) {
    return;
  }
  if (context.delta[2] !== TEXT_DIFF) {
    return;
  }
  const patch2 = getDiffMatchPatch(true).patch;
  context.setResult(patch2(context.left, context.delta[0])).exit();
};
patchFilter4.filterName = "texts";
var textDeltaReverse = function(delta) {
  let i;
  let l;
  let lines;
  let line;
  let lineTmp;
  let header = null;
  const headerRegex = /^@@ +-(\d+),(\d+) +\+(\d+),(\d+) +@@$/;
  let lineHeader;
  lines = delta.split("\n");
  for (i = 0, l = lines.length; i < l; i++) {
    line = lines[i];
    let lineStart = line.slice(0, 1);
    if (lineStart === "@") {
      header = headerRegex.exec(line);
      lineHeader = i;
      lines[lineHeader] = "@@ -" + header[3] + "," + header[4] + " +" + header[1] + "," + header[2] + " @@";
    } else if (lineStart === "+") {
      lines[i] = "-" + lines[i].slice(1);
      if (lines[i - 1].slice(0, 1) === "+") {
        lineTmp = lines[i];
        lines[i] = lines[i - 1];
        lines[i - 1] = lineTmp;
      }
    } else if (lineStart === "-") {
      lines[i] = "+" + lines[i].slice(1);
    }
  }
  return lines.join("\n");
};
var reverseFilter4 = function textsReverseFilter(context) {
  if (context.nested) {
    return;
  }
  if (context.delta[2] !== TEXT_DIFF) {
    return;
  }
  context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();
};
reverseFilter4.filterName = "texts";

// src/diffpatcher.ts
var DiffPatcher = class {
  constructor(options = {}) {
    this.processor = new processor_default(options);
    this.processor.pipe(
      new pipe_default("diff").append(
        collectChildrenDiffFilter,
        diffFilter,
        diffFilter3,
        diffFilter4,
        objectsDiffFilter,
        diffFilter2
      ).shouldHaveResult()
    );
    this.processor.pipe(
      new pipe_default("patch").append(
        collectChildrenPatchFilter,
        collectChildrenPatchFilter3,
        patchFilter,
        patchFilter4,
        patchFilter2,
        patchFilter3
      ).shouldHaveResult()
    );
    this.processor.pipe(
      new pipe_default("reverse").append(
        collectChildrenReverseFilter,
        collectChildrenReverseFilter2,
        reverseFilter,
        reverseFilter4,
        reverseFilter2,
        reverseFilter3
      ).shouldHaveResult()
    );
  }
  options(...args) {
    return this.processor.options(...args);
  }
  diff(left, right) {
    return this.processor.process(new diff_default(left, right));
  }
  patch(left, delta) {
    return this.processor.process(new patch_default(left, delta));
  }
  reverse(delta) {
    return this.processor.process(new reverse_default(delta));
  }
  unpatch(right, delta) {
    return this.patch(right, this.reverse(delta));
  }
  clone(value) {
    return clone(value);
  }
};
var diffpatcher_default = DiffPatcher;

// src/formatters/index.js
var formatters_exports = {};
__export(formatters_exports, {
  annotated: () => annotated_exports,
  base: () => base_exports,
  console: () => console_exports,
  html: () => html_exports,
  jsonpatch: () => jsonpatch_exports
});

// src/formatters/base.ts
var base_exports = {};
__export(base_exports, {
  default: () => base_default
});
var isArray4 = typeof Array.isArray === "function" ? Array.isArray : (a) => a instanceof Array;
var getObjectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (obj) => {
  const names = [];
  for (let property in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, property)) {
      names.push(property);
    }
  }
  return names;
};
var trimUnderscore = (str) => {
  if (str.substr(0, 1) === "_") {
    return str.slice(1);
  }
  return str;
};
var arrayKeyToSortNumber = (key) => {
  if (key === "_t") {
    return -1;
  } else {
    if (key.substr(0, 1) === "_") {
      return parseInt(key.slice(1), 10);
    } else {
      return parseInt(key, 10) + 0.1;
    }
  }
};
var arrayKeyComparer = (key1, key2) => arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2);
var BaseFormatter = class {
  format(delta, left) {
    const context = {};
    this.prepareContext(context);
    this.recurse(context, delta, left);
    return this.finalize(context);
  }
  prepareContext(context) {
    context.buffer = [];
    context.out = function(...args) {
      this.buffer.push(...args);
    };
  }
  typeFormatterNotFound(context, deltaType) {
    throw new Error(`cannot format delta type: ${deltaType}`);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  typeFormatterErrorFormatter(context, err, ...rest) {
    return err.toString();
  }
  finalize({ buffer }) {
    if (isArray4(buffer)) {
      return buffer.join("");
    }
  }
  recurse(context, delta, left, key, leftKey, movedFrom, isLast) {
    const useMoveOriginHere = delta && movedFrom;
    const leftValue = useMoveOriginHere ? movedFrom.value : left;
    if (typeof delta === "undefined" && typeof key === "undefined") {
      return void 0;
    }
    const type = this.getDeltaType(delta, movedFrom);
    const nodeType = type === "node" ? delta._t === "a" ? "array" : "object" : "";
    if (typeof key !== "undefined") {
      this.nodeBegin(context, key, leftKey, type, nodeType, isLast);
    } else {
      this.rootBegin(context, type, nodeType);
    }
    let typeFormatter;
    try {
      typeFormatter = this[`format_${type}`] || this.typeFormatterNotFound(context, type);
      typeFormatter.call(
        this,
        context,
        delta,
        leftValue,
        key,
        leftKey,
        movedFrom
      );
    } catch (err) {
      this.typeFormatterErrorFormatter(
        context,
        err,
        delta,
        leftValue,
        key,
        leftKey,
        movedFrom
      );
      if (typeof console !== "undefined" && console.error) {
        console.error(err.stack);
      }
    }
    if (typeof key !== "undefined") {
      this.nodeEnd(context, key, leftKey, type, nodeType, isLast);
    } else {
      this.rootEnd(context, type, nodeType);
    }
  }
  formatDeltaChildren(context, delta, left) {
    const self = this;
    this.forEachDeltaKey(delta, left, (key, leftKey, movedFrom, isLast) => {
      self.recurse(
        context,
        delta[key],
        left ? left[leftKey] : void 0,
        key,
        leftKey,
        movedFrom,
        isLast
      );
    });
  }
  forEachDeltaKey(delta, left, fn) {
    const keys = getObjectKeys(delta);
    const arrayKeys = delta._t === "a";
    const moveDestinations = {};
    let name;
    if (typeof left !== "undefined") {
      for (name in left) {
        if (Object.prototype.hasOwnProperty.call(left, name)) {
          if (typeof delta[name] === "undefined" && (!arrayKeys || typeof delta[`_${name}`] === "undefined")) {
            keys.push(name);
          }
        }
      }
    }
    for (name in delta) {
      if (Object.prototype.hasOwnProperty.call(delta, name)) {
        const value = delta[name];
        if (isArray4(value) && value[2] === 3) {
          moveDestinations[value[1].toString()] = {
            key: name,
            value: left && left[parseInt(name.substr(1))]
          };
          if (this.includeMoveDestinations !== false) {
            if (typeof left === "undefined" && typeof delta[value[1]] === "undefined") {
              keys.push(value[1].toString());
            }
          }
        }
      }
    }
    if (arrayKeys) {
      keys.sort(arrayKeyComparer);
    } else {
      keys.sort();
    }
    for (let index = 0, length = keys.length; index < length; index++) {
      const key = keys[index];
      if (arrayKeys && key === "_t") {
        continue;
      }
      const leftKey = arrayKeys ? typeof key === "number" ? key : parseInt(trimUnderscore(key), 10) : key;
      const isLast = index === length - 1;
      fn(key, leftKey, moveDestinations[leftKey], isLast);
    }
  }
  getDeltaType(delta, movedFrom) {
    if (typeof delta === "undefined") {
      if (typeof movedFrom !== "undefined") {
        return "movedestination";
      }
      return "unchanged";
    }
    if (isArray4(delta)) {
      if (delta.length === 1) {
        return "added";
      }
      if (delta.length === 2) {
        return "modified";
      }
      if (delta.length === 3 && delta[2] === 0) {
        return "deleted";
      }
      if (delta.length === 3 && delta[2] === 2) {
        return "textdiff";
      }
      if (delta.length === 3 && delta[2] === 3) {
        return "moved";
      }
    } else if (typeof delta === "object") {
      return "node";
    }
    return "unknown";
  }
  parseTextDiff(value) {
    const output = [];
    const lines = value.split("\n@@ ");
    for (let i = 0, l = lines.length; i < l; i++) {
      const line = lines[i];
      const lineOutput = {
        pieces: []
      };
      const location = /^(?:@@ )?[-+]?(\d+),(\d+)/.exec(line).slice(1);
      lineOutput.location = {
        line: location[0],
        chr: location[1]
      };
      const pieces = line.split("\n").slice(1);
      for (let pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
        const piece = pieces[pieceIndex];
        if (!piece.length) {
          continue;
        }
        const pieceOutput = {
          type: "context"
        };
        if (piece.substr(0, 1) === "+") {
          pieceOutput.type = "added";
        } else if (piece.substr(0, 1) === "-") {
          pieceOutput.type = "deleted";
        }
        pieceOutput.text = piece.slice(1);
        lineOutput.pieces.push(pieceOutput);
      }
      output.push(lineOutput);
    }
    return output;
  }
  nodeBegin(context, key, leftKey, type, nodeType, isLast) {
    throw new Error("::nodeBegin Not implemented!");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  rootBegin(context, type, nodeType) {
    throw new Error("::rootBegin Not implemented!");
  }
  nodeEnd(context, key, leftKey, type, nodeType, isLast) {
    throw new Error("::nodeEnd Not implemented!");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  rootEnd(context, type, nodeType) {
    throw new Error("::rootEnd Not implemented!");
  }
};
var base_default = BaseFormatter;

// src/formatters/html.js
var html_exports = {};
__export(html_exports, {
  default: () => html_default,
  format: () => format,
  hideUnchanged: () => hideUnchanged,
  showUnchanged: () => showUnchanged
});
var HtmlFormatter = class extends base_default {
  typeFormatterErrorFormatter(context, err) {
    context.out(`<pre class="jsondiffpatch-error">${err}</pre>`);
  }
  formatValue(context, value) {
    context.out(`<pre>${htmlEscape(JSON.stringify(value, null, 2))}</pre>`);
  }
  formatTextDiffString(context, value) {
    let lines = this.parseTextDiff(value);
    context.out('<ul class="jsondiffpatch-textdiff">');
    for (let i = 0, l = lines.length; i < l; i++) {
      let line = lines[i];
      context.out(
        `<li><div class="jsondiffpatch-textdiff-location"><span class="jsondiffpatch-textdiff-line-number">${line.location.line}</span><span class="jsondiffpatch-textdiff-char">${line.location.chr}</span></div><div class="jsondiffpatch-textdiff-line">`
      );
      let pieces = line.pieces;
      for (let pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
        let piece = pieces[pieceIndex];
        context.out(
          `<span class="jsondiffpatch-textdiff-${piece.type}">${htmlEscape(
            decodeURI(piece.text)
          )}</span>`
        );
      }
      context.out("</div></li>");
    }
    context.out("</ul>");
  }
  rootBegin(context, type, nodeType) {
    let nodeClass = `jsondiffpatch-${type}${nodeType ? ` jsondiffpatch-child-node-type-${nodeType}` : ""}`;
    context.out(`<div class="jsondiffpatch-delta ${nodeClass}">`);
  }
  rootEnd(context) {
    context.out(
      `</div>${context.hasArrows ? `<script type="text/javascript">setTimeout(${adjustArrows.toString()},10);</script>` : ""}`
    );
  }
  nodeBegin(context, key, leftKey, type, nodeType) {
    let nodeClass = `jsondiffpatch-${type}${nodeType ? ` jsondiffpatch-child-node-type-${nodeType}` : ""}`;
    context.out(
      `<li class="${nodeClass}" data-key="${leftKey}"><div class="jsondiffpatch-property-name">${leftKey}</div>`
    );
  }
  nodeEnd(context) {
    context.out("</li>");
  }
  /* jshint camelcase: false */
  /* eslint-disable camelcase */
  format_unchanged(context, delta, left) {
    if (typeof left === "undefined") {
      return;
    }
    context.out('<div class="jsondiffpatch-value">');
    this.formatValue(context, left);
    context.out("</div>");
  }
  format_movedestination(context, delta, left) {
    if (typeof left === "undefined") {
      return;
    }
    context.out('<div class="jsondiffpatch-value">');
    this.formatValue(context, left);
    context.out("</div>");
  }
  format_node(context, delta, left) {
    let nodeType = delta._t === "a" ? "array" : "object";
    context.out(
      `<ul class="jsondiffpatch-node jsondiffpatch-node-type-${nodeType}">`
    );
    this.formatDeltaChildren(context, delta, left);
    context.out("</ul>");
  }
  format_added(context, delta) {
    context.out('<div class="jsondiffpatch-value">');
    this.formatValue(context, delta[0]);
    context.out("</div>");
  }
  format_modified(context, delta) {
    context.out('<div class="jsondiffpatch-value jsondiffpatch-left-value">');
    this.formatValue(context, delta[0]);
    context.out(
      '</div><div class="jsondiffpatch-value jsondiffpatch-right-value">'
    );
    this.formatValue(context, delta[1]);
    context.out("</div>");
  }
  format_deleted(context, delta) {
    context.out('<div class="jsondiffpatch-value">');
    this.formatValue(context, delta[0]);
    context.out("</div>");
  }
  format_moved(context, delta) {
    context.out('<div class="jsondiffpatch-value">');
    this.formatValue(context, delta[0]);
    context.out(
      `</div><div class="jsondiffpatch-moved-destination">${delta[1]}</div>`
    );
    context.out(
      /* jshint multistr: true */
      `<div class="jsondiffpatch-arrow" style="position: relative; left: -34px;">
          <svg width="30" height="60" style="position: absolute; display: none;">
          <defs>
              <marker id="markerArrow" markerWidth="8" markerHeight="8"
                 refx="2" refy="4"
                     orient="auto" markerUnits="userSpaceOnUse">
                  <path d="M1,1 L1,7 L7,4 L1,1" style="fill: #339;" />
              </marker>
          </defs>
          <path d="M30,0 Q-10,25 26,50"
            style="stroke: #88f; stroke-width: 2px; fill: none; stroke-opacity: 0.5; marker-end: url(#markerArrow);"
          ></path>
          </svg>
      </div>`
    );
    context.hasArrows = true;
  }
  format_textdiff(context, delta) {
    context.out('<div class="jsondiffpatch-value">');
    this.formatTextDiffString(context, delta[0]);
    context.out("</div>");
  }
};
function htmlEscape(text) {
  let html = text;
  let replacements = [
    [/&/g, "&amp;"],
    [/</g, "&lt;"],
    [/>/g, "&gt;"],
    [/'/g, "&apos;"],
    [/"/g, "&quot;"]
  ];
  for (let i = 0; i < replacements.length; i++) {
    html = html.replace(replacements[i][0], replacements[i][1]);
  }
  return html;
}
var adjustArrows = function jsondiffpatchHtmlFormatterAdjustArrows(nodeArg) {
  const node = nodeArg || document;
  let getElementText = ({ textContent, innerText }) => textContent || innerText;
  let eachByQuery = (el, query, fn) => {
    let elems = el.querySelectorAll(query);
    for (let i = 0, l = elems.length; i < l; i++) {
      fn(elems[i]);
    }
  };
  let eachChildren = ({ children }, fn) => {
    for (let i = 0, l = children.length; i < l; i++) {
      fn(children[i], i);
    }
  };
  eachByQuery(
    node,
    ".jsondiffpatch-arrow",
    ({ parentNode, children, style }) => {
      let arrowParent = parentNode;
      let svg = children[0];
      let path = svg.children[1];
      svg.style.display = "none";
      let destination = getElementText(
        arrowParent.querySelector(".jsondiffpatch-moved-destination")
      );
      let container = arrowParent.parentNode;
      let destinationElem;
      eachChildren(container, (child) => {
        if (child.getAttribute("data-key") === destination) {
          destinationElem = child;
        }
      });
      if (!destinationElem) {
        return;
      }
      try {
        let distance = destinationElem.offsetTop - arrowParent.offsetTop;
        svg.setAttribute("height", Math.abs(distance) + 6);
        style.top = `${-8 + (distance > 0 ? 0 : distance)}px`;
        let curve = distance > 0 ? `M30,0 Q-10,${Math.round(distance / 2)} 26,${distance - 4}` : `M30,${-distance} Q-10,${Math.round(-distance / 2)} 26,4`;
        path.setAttribute("d", curve);
        svg.style.display = "";
      } catch (err) {
      }
    }
  );
};
var showUnchanged = (show, node, delay) => {
  let el = node || document.body;
  let prefix = "jsondiffpatch-unchanged-";
  let classes = {
    showing: `${prefix}showing`,
    hiding: `${prefix}hiding`,
    visible: `${prefix}visible`,
    hidden: `${prefix}hidden`
  };
  let list = el.classList;
  if (!list) {
    return;
  }
  if (!delay) {
    list.remove(classes.showing);
    list.remove(classes.hiding);
    list.remove(classes.visible);
    list.remove(classes.hidden);
    if (show === false) {
      list.add(classes.hidden);
    }
    return;
  }
  if (show === false) {
    list.remove(classes.showing);
    list.add(classes.visible);
    setTimeout(() => {
      list.add(classes.hiding);
    }, 10);
  } else {
    list.remove(classes.hiding);
    list.add(classes.showing);
    list.remove(classes.hidden);
  }
  let intervalId = setInterval(() => {
    adjustArrows(el);
  }, 100);
  setTimeout(() => {
    list.remove(classes.showing);
    list.remove(classes.hiding);
    if (show === false) {
      list.add(classes.hidden);
      list.remove(classes.visible);
    } else {
      list.add(classes.visible);
      list.remove(classes.hidden);
    }
    setTimeout(() => {
      list.remove(classes.visible);
      clearInterval(intervalId);
    }, delay + 400);
  }, delay);
};
var hideUnchanged = (node, delay) => showUnchanged(false, node, delay);
var html_default = HtmlFormatter;
var defaultInstance;
function format(delta, left) {
  if (!defaultInstance) {
    defaultInstance = new HtmlFormatter();
  }
  return defaultInstance.format(delta, left);
}

// src/formatters/annotated.js
var annotated_exports = {};
__export(annotated_exports, {
  default: () => annotated_default,
  format: () => format2
});
var AnnotatedFormatter = class extends base_default {
  constructor() {
    super();
    this.includeMoveDestinations = false;
  }
  prepareContext(context) {
    super.prepareContext(context);
    context.indent = function(levels) {
      this.indentLevel = (this.indentLevel || 0) + (typeof levels === "undefined" ? 1 : levels);
      this.indentPad = new Array(this.indentLevel + 1).join("&nbsp;&nbsp;");
    };
    context.row = (json, htmlNote) => {
      context.out(
        '<tr><td style="white-space: nowrap;"><pre class="jsondiffpatch-annotated-indent" style="display: inline-block">'
      );
      context.out(context.indentPad);
      context.out('</pre><pre style="display: inline-block">');
      context.out(json);
      context.out('</pre></td><td class="jsondiffpatch-delta-note"><div>');
      context.out(htmlNote);
      context.out("</div></td></tr>");
    };
  }
  typeFormatterErrorFormatter(context, err) {
    context.row("", `<pre class="jsondiffpatch-error">${err}</pre>`);
  }
  formatTextDiffString(context, value) {
    const lines = this.parseTextDiff(value);
    context.out('<ul class="jsondiffpatch-textdiff">');
    for (let i = 0, l = lines.length; i < l; i++) {
      const line = lines[i];
      context.out(
        `<li><div class="jsondiffpatch-textdiff-location"><span class="jsondiffpatch-textdiff-line-number">${line.location.line}</span><span class="jsondiffpatch-textdiff-char">${line.location.chr}</span></div><div class="jsondiffpatch-textdiff-line">`
      );
      const pieces = line.pieces;
      for (let pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
        const piece = pieces[pieceIndex];
        context.out(
          `<span class="jsondiffpatch-textdiff-${piece.type}">${piece.text}</span>`
        );
      }
      context.out("</div></li>");
    }
    context.out("</ul>");
  }
  rootBegin(context, type, nodeType) {
    context.out('<table class="jsondiffpatch-annotated-delta">');
    if (type === "node") {
      context.row("{");
      context.indent();
    }
    if (nodeType === "array") {
      context.row(
        '"_t": "a",',
        "Array delta (member names indicate array indices)"
      );
    }
  }
  rootEnd(context, type) {
    if (type === "node") {
      context.indent(-1);
      context.row("}");
    }
    context.out("</table>");
  }
  nodeBegin(context, key, leftKey, type, nodeType) {
    context.row(`&quot;${key}&quot;: {`);
    if (type === "node") {
      context.indent();
    }
    if (nodeType === "array") {
      context.row(
        '"_t": "a",',
        "Array delta (member names indicate array indices)"
      );
    }
  }
  nodeEnd(context, key, leftKey, type, nodeType, isLast) {
    if (type === "node") {
      context.indent(-1);
    }
    context.row(`}${isLast ? "" : ","}`);
  }
  /* jshint camelcase: false */
  /* eslint-disable camelcase */
  format_unchanged() {
  }
  format_movedestination() {
  }
  format_node(context, delta, left) {
    this.formatDeltaChildren(context, delta, left);
  }
};
var wrapPropertyName = (name) => `<pre style="display:inline-block">&quot;${name}&quot;</pre>`;
var deltaAnnotations = {
  added(delta, left, key, leftKey) {
    const formatLegend = " <pre>([newValue])</pre>";
    if (typeof leftKey === "undefined") {
      return `new value${formatLegend}`;
    }
    if (typeof leftKey === "number") {
      return `insert at index ${leftKey}${formatLegend}`;
    }
    return `add property ${wrapPropertyName(leftKey)}${formatLegend}`;
  },
  modified(delta, left, key, leftKey) {
    const formatLegend = " <pre>([previousValue, newValue])</pre>";
    if (typeof leftKey === "undefined") {
      return `modify value${formatLegend}`;
    }
    if (typeof leftKey === "number") {
      return `modify at index ${leftKey}${formatLegend}`;
    }
    return `modify property ${wrapPropertyName(leftKey)}${formatLegend}`;
  },
  deleted(delta, left, key, leftKey) {
    const formatLegend = " <pre>([previousValue, 0, 0])</pre>";
    if (typeof leftKey === "undefined") {
      return `delete value${formatLegend}`;
    }
    if (typeof leftKey === "number") {
      return `remove index ${leftKey}${formatLegend}`;
    }
    return `delete property ${wrapPropertyName(leftKey)}${formatLegend}`;
  },
  moved(delta, left, key, leftKey) {
    return `move from <span title="(position to remove at original state)">index ${leftKey}</span> to <span title="(position to insert at final state)">index ${delta[1]}</span>`;
  },
  textdiff(delta, left, key, leftKey) {
    const location = typeof leftKey === "undefined" ? "" : typeof leftKey === "number" ? ` at index ${leftKey}` : ` at property ${wrapPropertyName(leftKey)}`;
    return `text diff${location}, format is <a href="https://code.google.com/p/google-diff-match-patch/wiki/Unidiff">a variation of Unidiff</a>`;
  }
};
var formatAnyChange = function(context, delta) {
  const deltaType = this.getDeltaType(delta);
  const annotator = deltaAnnotations[deltaType];
  const htmlNote = annotator && annotator.apply(annotator, Array.prototype.slice.call(arguments, 1));
  let json = JSON.stringify(delta, null, 2);
  if (deltaType === "textdiff") {
    json = json.split("\\n").join('\\n"+\n   "');
  }
  context.indent();
  context.row(json, htmlNote);
  context.indent(-1);
};
AnnotatedFormatter.prototype.format_added = formatAnyChange;
AnnotatedFormatter.prototype.format_modified = formatAnyChange;
AnnotatedFormatter.prototype.format_deleted = formatAnyChange;
AnnotatedFormatter.prototype.format_moved = formatAnyChange;
AnnotatedFormatter.prototype.format_textdiff = formatAnyChange;
var annotated_default = AnnotatedFormatter;
var defaultInstance2;
function format2(delta, left) {
  if (!defaultInstance2) {
    defaultInstance2 = new AnnotatedFormatter();
  }
  return defaultInstance2.format(delta, left);
}

// src/formatters/jsonpatch.ts
var jsonpatch_exports = {};
__export(jsonpatch_exports, {
  default: () => jsonpatch_default,
  format: () => format3,
  log: () => log,
  partitionOps: () => partitionOps
});
var OPERATIONS = {
  add: "add",
  remove: "remove",
  replace: "replace",
  move: "move"
};
var JSONFormatter = class extends base_default {
  constructor() {
    super();
    this.includeMoveDestinations = true;
  }
  prepareContext(context) {
    super.prepareContext(context);
    context.result = [];
    context.path = [];
    context.pushCurrentOp = function(obj) {
      const { op, value } = obj;
      const val = {
        op,
        path: this.currentPath()
      };
      if (typeof value !== "undefined") {
        val.value = value;
      }
      this.result.push(val);
    };
    context.pushMoveOp = function(to) {
      const from = this.currentPath();
      this.result.push({
        op: OPERATIONS.move,
        from,
        path: this.toPath(to)
      });
    };
    context.currentPath = function() {
      return `/${this.path.join("/")}`;
    };
    context.toPath = function(toPath) {
      const to = this.path.slice();
      to[to.length - 1] = toPath;
      return `/${to.join("/")}`;
    };
  }
  typeFormatterErrorFormatter(context, err) {
    context.out(`[ERROR] ${err}`);
  }
  rootBegin() {
  }
  rootEnd() {
  }
  nodeBegin({ path }, key, leftKey) {
    path.push(leftKey);
  }
  nodeEnd({ path }) {
    path.pop();
  }
  /* jshint camelcase: false */
  /* eslint-disable camelcase */
  format_unchanged() {
  }
  format_movedestination() {
  }
  format_node(context, delta, left) {
    this.formatDeltaChildren(context, delta, left);
  }
  format_added(context, delta) {
    context.pushCurrentOp({ op: OPERATIONS.add, value: delta[0] });
  }
  format_modified(context, delta) {
    context.pushCurrentOp({ op: OPERATIONS.replace, value: delta[1] });
  }
  format_deleted(context) {
    context.pushCurrentOp({ op: OPERATIONS.remove });
  }
  format_moved(context, delta) {
    const to = delta[1];
    context.pushMoveOp(to);
  }
  format_textdiff() {
    throw new Error("Not implemented");
  }
  format(delta, left) {
    let context = {};
    this.prepareContext(context);
    this.recurse(context, delta, left);
    return context.result;
  }
};
var jsonpatch_default = JSONFormatter;
var last = (arr) => arr[arr.length - 1];
var sortBy = (arr, pred) => {
  arr.sort(pred);
  return arr;
};
var compareByIndexDesc = (indexA, indexB) => {
  const lastA = parseInt(indexA, 10);
  const lastB = parseInt(indexB, 10);
  if (!(isNaN(lastA) || isNaN(lastB))) {
    return lastB - lastA;
  } else {
    return 0;
  }
};
var opsByDescendingOrder = (removeOps) => sortBy(removeOps, (a, b) => {
  const splitA = a.path.split("/");
  const splitB = b.path.split("/");
  if (splitA.length !== splitB.length) {
    return splitA.length - splitB.length;
  } else {
    return compareByIndexDesc(last(splitA), last(splitB));
  }
});
var partitionOps = (arr, fns) => {
  const initArr = Array(fns.length + 1).fill().map(() => []);
  return arr.map((item) => {
    let position = fns.map((fn) => fn(item)).indexOf(true);
    if (position < 0) {
      position = fns.length;
    }
    return { item, position };
  }).reduce((acc, item) => {
    acc[item.position].push(item.item);
    return acc;
  }, initArr);
};
var isMoveOp = ({ op }) => op === "move";
var isRemoveOp = ({ op }) => op === "remove";
var reorderOps = (diff2) => {
  const [moveOps, removedOps, restOps] = partitionOps(diff2, [
    isMoveOp,
    isRemoveOp
  ]);
  const removeOpsReverse = opsByDescendingOrder(removedOps);
  return [...removeOpsReverse, ...moveOps, ...restOps];
};
var defaultInstance3;
var format3 = (delta, left) => {
  if (!defaultInstance3) {
    defaultInstance3 = new JSONFormatter();
  }
  return reorderOps(defaultInstance3.format(delta, left));
};
var log = (delta, left) => {
  console.log(format3(delta, left));
};

// src/formatters/console.js
var console_exports = {};
__export(console_exports, {
  default: () => console_default,
  format: () => format4,
  log: () => log2
});
var ConsoleFormatter = class extends base_default {
  constructor() {
    super();
    this.includeMoveDestinations = false;
  }
  prepareContext(context) {
    super.prepareContext(context);
    context.indent = function(levels) {
      this.indentLevel = (this.indentLevel || 0) + (typeof levels === "undefined" ? 1 : levels);
      this.indentPad = new Array(this.indentLevel + 1).join("  ");
      this.outLine();
    };
    context.outLine = function() {
      this.buffer.push(`
${this.indentPad || ""}`);
    };
    context.out = function(...args) {
      for (let i = 0, l = args.length; i < l; i++) {
        let lines = args[i].split("\n");
        let text = lines.join(`
${this.indentPad || ""}`);
        if (this.color && this.color[0]) {
          text = this.color[0](text);
        }
        this.buffer.push(text);
      }
    };
    context.pushColor = function(color) {
      this.color = this.color || [];
      this.color.unshift(color);
    };
    context.popColor = function() {
      this.color = this.color || [];
      this.color.shift();
    };
  }
  typeFormatterErrorFormatter(context, err) {
    context.out(`[ERROR]${err}`);
    context.popColor();
  }
  formatValue(context, value) {
    context.out(JSON.stringify(value, null, 2));
  }
  formatTextDiffString(context, value) {
    let lines = this.parseTextDiff(value);
    context.indent();
    for (let i = 0, l = lines.length; i < l; i++) {
      let line = lines[i];
      context.out(`${line.location.line},${line.location.chr} `);
      context.popColor();
      let pieces = line.pieces;
      for (let pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
        let piece = pieces[pieceIndex];
        context.out(piece.text);
        context.popColor();
      }
      if (i < l - 1) {
        context.outLine();
      }
    }
    context.indent(-1);
  }
  rootBegin(context, type, nodeType) {
    if (type === "node") {
      context.out(nodeType === "array" ? "[" : "{");
      context.indent();
    }
  }
  rootEnd(context, type, nodeType) {
    if (type === "node") {
      context.indent(-1);
      context.out(nodeType === "array" ? "]" : "}");
    }
    context.popColor();
  }
  nodeBegin(context, key, leftKey, type, nodeType) {
    context.out(`${leftKey}: `);
    if (type === "node") {
      context.out(nodeType === "array" ? "[" : "{");
      context.indent();
    }
  }
  nodeEnd(context, key, leftKey, type, nodeType, isLast) {
    if (type === "node") {
      context.indent(-1);
      context.out(nodeType === "array" ? "]" : `}${isLast ? "" : ","}`);
    }
    if (!isLast) {
      context.outLine();
    }
    context.popColor();
  }
  /* jshint camelcase: false */
  /* eslint-disable camelcase */
  format_unchanged(context, delta, left) {
    if (typeof left === "undefined") {
      return;
    }
    this.formatValue(context, left);
  }
  format_movedestination(context, delta, left) {
    if (typeof left === "undefined") {
      return;
    }
    this.formatValue(context, left);
  }
  format_node(context, delta, left) {
    this.formatDeltaChildren(context, delta, left);
  }
  format_added(context, delta) {
    this.formatValue(context, delta[0]);
  }
  format_modified(context, delta) {
    this.formatValue(context, delta[0]);
    context.popColor();
    context.out(" => ");
    this.formatValue(context, delta[1]);
    context.popColor();
  }
  format_deleted(context, delta) {
    this.formatValue(context, delta[0]);
  }
  format_moved(context, delta) {
    context.out(`==> ${delta[1]}`);
  }
  format_textdiff(context, delta) {
    this.formatTextDiffString(context, delta[0]);
  }
};
var console_default = ConsoleFormatter;
var defaultInstance4;
var format4 = (delta, left) => {
  if (!defaultInstance4) {
    defaultInstance4 = new ConsoleFormatter();
  }
  return defaultInstance4.format(delta, left);
};
function log2(delta, left) {
  console.log(format4(delta, left));
}

// src/index.ts
function create(options) {
  return new diffpatcher_default(options);
}
var defaultInstance5;
function diff(left, right) {
  if (!defaultInstance5) {
    defaultInstance5 = new diffpatcher_default();
  }
  return defaultInstance5.diff(left, right);
}
function patch(left, delta) {
  if (!defaultInstance5) {
    defaultInstance5 = new diffpatcher_default();
  }
  return defaultInstance5.patch(left, delta);
}
function unpatch(right, delta) {
  if (!defaultInstance5) {
    defaultInstance5 = new diffpatcher_default();
  }
  return defaultInstance5.unpatch(right, delta);
}
function reverse(delta) {
  if (!defaultInstance5) {
    defaultInstance5 = new diffpatcher_default();
  }
  return defaultInstance5.reverse(delta);
}
function clone2(value) {
  if (!defaultInstance5) {
    defaultInstance5 = new diffpatcher_default();
  }
  return defaultInstance5.clone(value);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DiffPatcher,
  clone,
  console,
  create,
  diff,
  formatters,
  patch,
  reverse,
  unpatch
});
