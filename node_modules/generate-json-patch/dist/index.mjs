// src/move-operations.ts
function longestCommonSequence(leftHashes, rightHashes) {
  const m = leftHashes.length;
  const n = rightHashes.length;
  const dp = Array.from(
    { length: m + 1 },
    () => Array(n + 1).fill(0)
  );
  let longestSequence = [];
  let offset = null;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (leftHashes[i - 1] === rightHashes[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
        if (dp[i][j] > longestSequence.length) {
          longestSequence = leftHashes.slice(i - dp[i][j], i);
          offset = i - dp[i][j];
        }
      } else {
        dp[i][j] = 0;
      }
    }
  }
  return {
    length: longestSequence.length,
    sequence: longestSequence,
    offset
  };
}
function moveOperations(leftHashes, rightHashes, currentPath = "") {
  const { sequence } = longestCommonSequence(leftHashes, rightHashes);
  const operations = [];
  let workingArr = [...leftHashes];
  let lcsIndex = 0;
  let targetIndex = 0;
  while (targetIndex < rightHashes.length) {
    const targetValue = rightHashes[targetIndex];
    if (sequence[lcsIndex] === targetValue) {
      lcsIndex++;
      targetIndex++;
      continue;
    }
    const sourceIndex = workingArr.indexOf(targetValue);
    if (sourceIndex !== targetIndex && sourceIndex !== -1) {
      operations.push({
        op: "move",
        from: `${currentPath}/${sourceIndex}`,
        path: `${currentPath}/${targetIndex}`
      });
      const [movedItem] = workingArr.splice(sourceIndex, 1);
      workingArr.splice(targetIndex, 0, movedItem);
    }
    targetIndex++;
  }
  return operations;
}

// src/index.ts
var defaultObjectHash = (obj, context) => {
  return context.index.toString();
};
function generateJSONPatch(before, after, config = {}) {
  const { objectHash = defaultObjectHash, propertyFilter } = config;
  const patch = [];
  const hasPropertyFilter = typeof propertyFilter === "function";
  function compareArrays(leftArr, rightArr, path) {
    var _a;
    if (JSON.stringify(leftArr) === JSON.stringify(rightArr))
      return;
    const leftHashes = leftArr.map(
      (value, index) => objectHash(value, { side: "left", path, index })
    );
    const rightHashes = rightArr.map(
      (value, index) => objectHash(value, { side: "right", path, index })
    );
    let currentIndex = leftArr.length - 1;
    const targetHashes = [];
    for (let i = leftArr.length - 1; i >= 0; i--) {
      const newPathIndex = `${path}/${currentIndex--}`;
      const rightHashIndex = rightHashes.indexOf(leftHashes[i]);
      if (rightHashIndex >= 0) {
        compareObjects(newPathIndex, leftArr[i], rightArr[rightHashIndex]);
        targetHashes.unshift(leftHashes[i]);
      } else {
        patch.push({ op: "remove", path: newPathIndex });
      }
    }
    const toBeAddedHashes = rightHashes.filter(
      (hash) => !targetHashes.includes(hash)
    );
    currentIndex = targetHashes.length;
    for (const toBeAddedHash of toBeAddedHashes) {
      patch.push({
        op: "add",
        path: `${path}/${currentIndex++}`,
        value: rightArr[rightHashes.indexOf(toBeAddedHash)]
      });
      targetHashes.push(toBeAddedHash);
    }
    if ((_a = config.array) == null ? void 0 : _a.ignoreMove) {
      return;
    }
    const moveOps = moveOperations(targetHashes, rightHashes, path);
    patch.push(...moveOps);
  }
  function compareObjects(path, leftJsonValue, rightJsonValue) {
    const isArrayAtTop = path === "" && [leftJsonValue, rightJsonValue].every(Array.isArray);
    if (isPrimitiveValue(leftJsonValue) || isPrimitiveValue(rightJsonValue)) {
      if (leftJsonValue !== rightJsonValue) {
        patch.push({ op: "replace", path, value: rightJsonValue });
      }
      return;
    }
    if (isArrayAtTop) {
      return compareArrays(leftJsonValue, rightJsonValue, "");
    }
    if ([leftJsonValue, rightJsonValue].some(Array.isArray)) {
      patch.push({ op: "replace", path, value: rightJsonValue });
      return;
    }
    for (const rightKey in rightJsonValue) {
      if (hasPropertyFilter && !propertyFilter(rightKey, { side: "right", path }))
        continue;
      let newPath = isArrayAtTop && path === "" ? `/${rightKey}` : `${path}/${rightKey}`;
      const leftValue = leftJsonValue[rightKey];
      const rightValue = rightJsonValue[rightKey];
      if (Array.isArray(leftValue) && Array.isArray(rightValue)) {
        compareArrays(leftValue, rightValue, newPath);
      } else if (isJsonObject(rightValue)) {
        if (isJsonObject(leftValue)) {
          compareObjects(newPath, leftValue, rightValue);
        } else if (leftJsonValue.hasOwnProperty(rightKey)) {
          patch.push({ op: "replace", path: newPath, value: rightValue });
        } else {
          patch.push({ op: "add", path: newPath, value: rightValue });
        }
      } else if (!leftJsonValue.hasOwnProperty(rightKey)) {
        patch.push({ op: "add", path: newPath, value: rightValue });
      } else if (leftValue !== rightValue) {
        patch.push({ op: "replace", path: newPath, value: rightValue });
      }
    }
    for (const leftKey in leftJsonValue) {
      if (!leftJsonValue.hasOwnProperty(leftKey) || hasPropertyFilter && !propertyFilter(leftKey, { side: "left", path }))
        continue;
      if (!rightJsonValue.hasOwnProperty(leftKey)) {
        let newPath = isArrayAtTop && path === "" ? `/${leftKey}` : `${path}/${leftKey}`;
        patch.push({ op: "remove", path: newPath });
      }
    }
  }
  compareObjects("", before, after);
  return [...patch];
}
function isPrimitiveValue(value) {
  return value === void 0 || value === null || typeof value === "undefined" || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
}
function isJsonObject(value) {
  return (value == null ? void 0 : value.constructor) === Object;
}
function pathInfo(path) {
  const segments = path.split("/");
  const length = segments.length;
  const last = segments[length - 1];
  return { segments, length, last };
}
export {
  defaultObjectHash,
  generateJSONPatch,
  pathInfo
};
